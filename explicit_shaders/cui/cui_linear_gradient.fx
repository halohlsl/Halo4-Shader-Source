#include "core/core.fxh"
#include "postprocessing/postprocess_parameters.fxh"
#include "cui_functions.fxh"

#include "cui_transform.fxh"		// adds the default vertex shader


#define k_color1 k_cui_pixel_shader_color0
#define k_color2 k_cui_pixel_shader_color1
#define k_color3 k_cui_pixel_shader_color2
#define k_color4 k_cui_pixel_shader_color3
#define k_scale k_cui_pixel_shader_color4

#define k_angle k_cui_pixel_shader_scalar0
#define k_offsetX k_cui_pixel_shader_scalar2
#define k_offsetY k_cui_pixel_shader_scalar3
#define k_numColors k_cui_pixel_shader_scalar4
#define k_gradientShape k_cui_pixel_shader_scalar5
#define k_tileMode k_cui_pixel_shader_scalar6

// ### HACK v-miroll: These should really be int's for performance sake. That would allow the conditional in the pixel shader
// to use a switch statement instead of a series of if's. For some reason, Cui shaders throw errors when using int's, though.
// You win this round, Cui.
#define k_gradientShapeLinear 0
#define k_gradientShapeCircular 1
#define k_gradientShapeDiamond 2
#define k_gradientShapeSquare 3

#define k_tileModeClamp 0
#define k_tileModeWrap 1
#define k_tileModeMirror 2

float4 default_ps(s_screen_vertex_output input) : SV_Target
{
	float4 color = cui_tex2D(input.texcoord);

	float2 gradientPosition;
	gradientPosition = (input.texcoord - k_cui_pixel_shader_authored_bounds.xy) /
		(k_cui_pixel_shader_authored_bounds.zw - k_cui_pixel_shader_authored_bounds.xy);

#ifdef xenon
	float4 gradients;
	asm {
		getGradients gradients, gradientPosition, source_sampler0
	};
#elif DX_VERSION == 11
	float4 gradients = GetGradients(gradientPosition);
#else
	float4 gradients = float4(1.0f, 0.0f, 0.0f, 1.0f);
#endif

	// Offset the origin of the gradient by (k_offsetX, k_offsetY) in screenspace pixels
	gradientPosition += (-k_offsetX * gradients.xy) + (-k_offsetY * gradients.zw);

	// Scale and rotate the gradient about it's center
	float2 rotatedPosition = float2(
		dot(gradientPosition-0.5, float2(cos(k_angle), -sin(k_angle))),
		dot(gradientPosition-0.5, float2(-sin(k_angle), -cos(k_angle))));

	rotatedPosition *= k_scale.xy;
	rotatedPosition += float2(0.5, 0.5);

	if (k_tileMode == k_tileModeWrap)
	{
		float2 uvTile;
		rotatedPosition = modf(rotatedPosition, uvTile);
		rotatedPosition = lerp(rotatedPosition, float2(1.0, 1.0) + rotatedPosition, step(rotatedPosition, float2(0.0, 0.0)));
	}
	else if (k_tileMode == k_tileModeMirror)
	{
		float2 uvTile;
		rotatedPosition = abs(modf(rotatedPosition, uvTile));

		uvTile = fmod(abs(uvTile), float2(2.0, 2.0));
		rotatedPosition = lerp(rotatedPosition, float2(1.0,1.0)-rotatedPosition, step(float2(1.0, 1.0), uvTile));
	}

	rotatedPosition = clamp(rotatedPosition, float2(0.0, 0.0), float2(1.0, 1.0));
	rotatedPosition -= float2(0.5, 0.5);

	float linearGradientTheta = 0.0;
	if (k_gradientShape == k_gradientShapeLinear)
	{
		linearGradientTheta = (rotatedPosition.x + 0.5) * (k_numColors - 1.0);
	}
	else if (k_gradientShape == k_gradientShapeCircular)
	{
		linearGradientTheta = length(rotatedPosition) * 2.0 * (k_numColors - 1.0);
	}
	else if (k_gradientShape == k_gradientShapeDiamond)
	{
		linearGradientTheta = (abs(rotatedPosition.x) + abs(rotatedPosition.y)) * 2.0 * (k_numColors - 1.0);
	}
	else if (k_gradientShape == k_gradientShapeSquare)
	{
		linearGradientTheta = max(abs(rotatedPosition.x), abs(rotatedPosition.y)) * 2.0 * (k_numColors - 1.0);
	}

	// Generate the three color ramps generated by the four color keys
	float4 ramp1 = lerp(k_color1, k_color2, saturate(linearGradientTheta));
	float4 ramp2 = lerp(k_color2, k_color3, saturate(linearGradientTheta-1.0));
	float4 ramp3 = lerp(k_color3, k_color4, saturate(linearGradientTheta-2.0));

	// Mask out the two unused color ramps by stepping the gradient theta
	float4 gradientColor =
		ramp1 * step(linearGradientTheta, 1.0) +
		ramp2 * step(linearGradientTheta, 2.0) * step(1.0, linearGradientTheta) +
		ramp3 * step(2.0, linearGradientTheta);

	// Tint the base map color and return the result
	color = cui_tint(color,
		cui_linear_to_gamma2(gradientColor),
		cui_linear_to_gamma2(k_cui_pixel_shader_tint));

	return color * ps_scale;
}

BEGIN_TECHNIQUE _default
{
	pass screen
	{
		SET_VERTEX_SHADER(default_vs());
		SET_PIXEL_SHADER(default_ps());
	}
}

BEGIN_TECHNIQUE curved_cui
{
	pass screen
	{
		SET_VERTEX_SHADER(curved_cui_vs());
		SET_PIXEL_SHADER(default_ps());
	}
}
